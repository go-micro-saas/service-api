// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/account-service/v1/resources/user.resource.v1.proto

package resourcev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	enumv1 "github.com/go-micro-saas/service-api/api/account-service/v1/enums"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = enumv1.UserGenderEnum_UserGender(0)
)

// Validate checks the field values on User with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *User) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UserMultiError, or nil if none found.
func (m *User) ValidateAll() error {
	return m.validate(true)
}

func (m *User) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CreatedTime

	// no validation rules for UpdatedTime

	// no validation rules for DeletedTime

	// no validation rules for UserId

	// no validation rules for UserPhone

	// no validation rules for UserEmail

	// no validation rules for UserNickname

	// no validation rules for UserAvatar

	// no validation rules for UserGender

	// no validation rules for UserStatus

	if len(errors) > 0 {
		return UserMultiError(errors)
	}

	return nil
}

// UserMultiError is an error wrapping multiple validation errors returned by
// User.ValidateAll() if the designated constraints aren't met.
type UserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMultiError) AllErrors() []error { return m }

// UserValidationError is the validation error returned by User.Validate if the
// designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

// Validate checks the field values on GetUserInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetUserInfoReqMultiError,
// or nil if none found.
func (m *GetUserInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUserId() <= 0 {
		err := GetUserInfoReqValidationError{
			field:  "UserId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUserInfoReqMultiError(errors)
	}

	return nil
}

// GetUserInfoReqMultiError is an error wrapping multiple validation errors
// returned by GetUserInfoReq.ValidateAll() if the designated constraints
// aren't met.
type GetUserInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoReqMultiError) AllErrors() []error { return m }

// GetUserInfoReqValidationError is the validation error returned by
// GetUserInfoReq.Validate if the designated constraints aren't met.
type GetUserInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoReqValidationError) ErrorName() string { return "GetUserInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e GetUserInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoReqValidationError{}

// Validate checks the field values on GetUserInfoResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserInfoRespMultiError, or nil if none found.
func (m *GetUserInfoResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Reason

	// no validation rules for Message

	// no validation rules for Metadata

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetUserInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetUserInfoRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetUserInfoRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetUserInfoRespMultiError(errors)
	}

	return nil
}

// GetUserInfoRespMultiError is an error wrapping multiple validation errors
// returned by GetUserInfoResp.ValidateAll() if the designated constraints
// aren't met.
type GetUserInfoRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoRespMultiError) AllErrors() []error { return m }

// GetUserInfoRespValidationError is the validation error returned by
// GetUserInfoResp.Validate if the designated constraints aren't met.
type GetUserInfoRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoRespValidationError) ErrorName() string { return "GetUserInfoRespValidationError" }

// Error satisfies the builtin error interface
func (e GetUserInfoRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoRespValidationError{}

// Validate checks the field values on AccountInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AccountInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccountInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AccountInfoMultiError, or
// nil if none found.
func (m *AccountInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *AccountInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreatedTime

	// no validation rules for UserId

	// no validation rules for UserPhone

	// no validation rules for UserEmail

	// no validation rules for UserNickname

	// no validation rules for UserAvatar

	// no validation rules for UserGender

	// no validation rules for UserStatus

	// no validation rules for RegisterType

	// no validation rules for DisableTime

	if len(errors) > 0 {
		return AccountInfoMultiError(errors)
	}

	return nil
}

// AccountInfoMultiError is an error wrapping multiple validation errors
// returned by AccountInfo.ValidateAll() if the designated constraints aren't met.
type AccountInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountInfoMultiError) AllErrors() []error { return m }

// AccountInfoValidationError is the validation error returned by
// AccountInfo.Validate if the designated constraints aren't met.
type AccountInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountInfoValidationError) ErrorName() string { return "AccountInfoValidationError" }

// Error satisfies the builtin error interface
func (e AccountInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccountInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountInfoValidationError{}

// Validate checks the field values on GetUserInfoListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserInfoListReqMultiError, or nil if none found.
func (m *GetUserInfoListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetUserIds()) < 1 {
		err := GetUserInfoListReqValidationError{
			field:  "UserIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetUserInfoListReqMultiError(errors)
	}

	return nil
}

// GetUserInfoListReqMultiError is an error wrapping multiple validation errors
// returned by GetUserInfoListReq.ValidateAll() if the designated constraints
// aren't met.
type GetUserInfoListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoListReqMultiError) AllErrors() []error { return m }

// GetUserInfoListReqValidationError is the validation error returned by
// GetUserInfoListReq.Validate if the designated constraints aren't met.
type GetUserInfoListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoListReqValidationError) ErrorName() string {
	return "GetUserInfoListReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserInfoListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoListReqValidationError{}

// Validate checks the field values on GetUserInfoListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserInfoListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserInfoListResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserInfoListRespMultiError, or nil if none found.
func (m *GetUserInfoListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserInfoListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Reason

	// no validation rules for Message

	// no validation rules for Metadata

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserInfoListRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserInfoListRespValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserInfoListRespValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetUserInfoListRespMultiError(errors)
	}

	return nil
}

// GetUserInfoListRespMultiError is an error wrapping multiple validation
// errors returned by GetUserInfoListResp.ValidateAll() if the designated
// constraints aren't met.
type GetUserInfoListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserInfoListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserInfoListRespMultiError) AllErrors() []error { return m }

// GetUserInfoListRespValidationError is the validation error returned by
// GetUserInfoListResp.Validate if the designated constraints aren't met.
type GetUserInfoListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserInfoListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserInfoListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserInfoListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserInfoListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserInfoListRespValidationError) ErrorName() string {
	return "GetUserInfoListRespValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserInfoListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserInfoListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserInfoListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserInfoListRespValidationError{}

// Validate checks the field values on UserListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserListReqMultiError, or
// nil if none found.
func (m *UserListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UserListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPageRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserListReqValidationError{
					field:  "PageRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserListReqValidationError{
					field:  "PageRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserListReqValidationError{
				field:  "PageRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ContactEmail

	// no validation rules for ContactPhone

	if len(errors) > 0 {
		return UserListReqMultiError(errors)
	}

	return nil
}

// UserListReqMultiError is an error wrapping multiple validation errors
// returned by UserListReq.ValidateAll() if the designated constraints aren't met.
type UserListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserListReqMultiError) AllErrors() []error { return m }

// UserListReqValidationError is the validation error returned by
// UserListReq.Validate if the designated constraints aren't met.
type UserListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserListReqValidationError) ErrorName() string { return "UserListReqValidationError" }

// Error satisfies the builtin error interface
func (e UserListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserListReqValidationError{}

// Validate checks the field values on UserListResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserListResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserListResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserListRespMultiError, or
// nil if none found.
func (m *UserListResp) ValidateAll() error {
	return m.validate(true)
}

func (m *UserListResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Reason

	// no validation rules for Message

	// no validation rules for Metadata

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserListRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserListRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserListRespMultiError(errors)
	}

	return nil
}

// UserListRespMultiError is an error wrapping multiple validation errors
// returned by UserListResp.ValidateAll() if the designated constraints aren't met.
type UserListRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserListRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserListRespMultiError) AllErrors() []error { return m }

// UserListRespValidationError is the validation error returned by
// UserListResp.Validate if the designated constraints aren't met.
type UserListRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserListRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserListRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserListRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserListRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserListRespValidationError) ErrorName() string { return "UserListRespValidationError" }

// Error satisfies the builtin error interface
func (e UserListRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserListResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserListRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserListRespValidationError{}

// Validate checks the field values on UserListRespData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserListRespData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserListRespData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserListRespDataMultiError, or nil if none found.
func (m *UserListRespData) ValidateAll() error {
	return m.validate(true)
}

func (m *UserListRespData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserListRespDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserListRespDataValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserListRespDataValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPageInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserListRespDataValidationError{
					field:  "PageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserListRespDataValidationError{
					field:  "PageInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserListRespDataValidationError{
				field:  "PageInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UserListRespDataMultiError(errors)
	}

	return nil
}

// UserListRespDataMultiError is an error wrapping multiple validation errors
// returned by UserListRespData.ValidateAll() if the designated constraints
// aren't met.
type UserListRespDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserListRespDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserListRespDataMultiError) AllErrors() []error { return m }

// UserListRespDataValidationError is the validation error returned by
// UserListRespData.Validate if the designated constraints aren't met.
type UserListRespDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserListRespDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserListRespDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserListRespDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserListRespDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserListRespDataValidationError) ErrorName() string { return "UserListRespDataValidationError" }

// Error satisfies the builtin error interface
func (e UserListRespDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserListRespData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserListRespDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserListRespDataValidationError{}

// Validate checks the field values on UserProcessResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserProcessResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserProcessResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserProcessResultMultiError, or nil if none found.
func (m *UserProcessResult) ValidateAll() error {
	return m.validate(true)
}

func (m *UserProcessResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsSuccess

	if len(errors) > 0 {
		return UserProcessResultMultiError(errors)
	}

	return nil
}

// UserProcessResultMultiError is an error wrapping multiple validation errors
// returned by UserProcessResult.ValidateAll() if the designated constraints
// aren't met.
type UserProcessResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserProcessResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserProcessResultMultiError) AllErrors() []error { return m }

// UserProcessResultValidationError is the validation error returned by
// UserProcessResult.Validate if the designated constraints aren't met.
type UserProcessResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserProcessResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserProcessResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserProcessResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserProcessResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserProcessResultValidationError) ErrorName() string {
	return "UserProcessResultValidationError"
}

// Error satisfies the builtin error interface
func (e UserProcessResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserProcessResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserProcessResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserProcessResultValidationError{}

// Validate checks the field values on CreateUserReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateUserReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateUserReqMultiError, or
// nil if none found.
func (m *CreateUserReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CreateUserReq_UserPhone_Pattern.MatchString(m.GetUserPhone()) {
		err := CreateUserReqValidationError{
			field:  "UserPhone",
			reason: "value does not match regex pattern \"^1[1-9]\\\\d{9}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateEmail(m.GetUserEmail()); err != nil {
		err = CreateUserReqValidationError{
			field:  "UserEmail",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUserNickname() != "" {

	}

	if m.GetUserAvatar() != "" {

	}

	if _, ok := _CreateUserReq_UserGender_NotInLookup[m.GetUserGender()]; ok {
		err := CreateUserReqValidationError{
			field:  "UserGender",
			reason: "value must not be in list [UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateUserReq_UserStatus_NotInLookup[m.GetUserStatus()]; ok {
		err := CreateUserReqValidationError{
			field:  "UserStatus",
			reason: "value must not be in list [INITIAL]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateUserReq_Password_Pattern.MatchString(m.GetPassword()) {
		err := CreateUserReqValidationError{
			field:  "Password",
			reason: "value does not match regex pattern \"^.{6,}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateUserReqMultiError(errors)
	}

	return nil
}

func (m *CreateUserReq) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *CreateUserReq) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CreateUserReqMultiError is an error wrapping multiple validation errors
// returned by CreateUserReq.ValidateAll() if the designated constraints
// aren't met.
type CreateUserReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserReqMultiError) AllErrors() []error { return m }

// CreateUserReqValidationError is the validation error returned by
// CreateUserReq.Validate if the designated constraints aren't met.
type CreateUserReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserReqValidationError) ErrorName() string { return "CreateUserReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateUserReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserReqValidationError{}

var _CreateUserReq_UserPhone_Pattern = regexp.MustCompile("^1[1-9]\\d{9}$")

var _CreateUserReq_UserGender_NotInLookup = map[enumv1.UserGenderEnum_UserGender]struct{}{
	0: {},
}

var _CreateUserReq_UserStatus_NotInLookup = map[enumv1.UserStatusEnum_UserStatus]struct{}{
	0: {},
}

var _CreateUserReq_Password_Pattern = regexp.MustCompile("^.{6,}$")

// Validate checks the field values on CreateUserByEmailReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUserByEmailReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserByEmailReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserByEmailReqMultiError, or nil if none found.
func (m *CreateUserByEmailReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserByEmailReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateEmail(m.GetUserEmail()); err != nil {
		err = CreateUserByEmailReqValidationError{
			field:  "UserEmail",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUserNickname() != "" {

	}

	if m.GetUserAvatar() != "" {

	}

	if _, ok := _CreateUserByEmailReq_UserGender_NotInLookup[m.GetUserGender()]; ok {
		err := CreateUserByEmailReqValidationError{
			field:  "UserGender",
			reason: "value must not be in list [UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateUserByEmailReq_UserStatus_NotInLookup[m.GetUserStatus()]; ok {
		err := CreateUserByEmailReqValidationError{
			field:  "UserStatus",
			reason: "value must not be in list [INITIAL]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateUserByEmailReq_Password_Pattern.MatchString(m.GetPassword()) {
		err := CreateUserByEmailReqValidationError{
			field:  "Password",
			reason: "value does not match regex pattern \"^.{6,}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateUserByEmailReqMultiError(errors)
	}

	return nil
}

func (m *CreateUserByEmailReq) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *CreateUserByEmailReq) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CreateUserByEmailReqMultiError is an error wrapping multiple validation
// errors returned by CreateUserByEmailReq.ValidateAll() if the designated
// constraints aren't met.
type CreateUserByEmailReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserByEmailReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserByEmailReqMultiError) AllErrors() []error { return m }

// CreateUserByEmailReqValidationError is the validation error returned by
// CreateUserByEmailReq.Validate if the designated constraints aren't met.
type CreateUserByEmailReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserByEmailReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserByEmailReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserByEmailReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserByEmailReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserByEmailReqValidationError) ErrorName() string {
	return "CreateUserByEmailReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserByEmailReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserByEmailReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserByEmailReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserByEmailReqValidationError{}

var _CreateUserByEmailReq_UserGender_NotInLookup = map[enumv1.UserGenderEnum_UserGender]struct{}{
	0: {},
}

var _CreateUserByEmailReq_UserStatus_NotInLookup = map[enumv1.UserStatusEnum_UserStatus]struct{}{
	0: {},
}

var _CreateUserByEmailReq_Password_Pattern = regexp.MustCompile("^.{6,}$")

// Validate checks the field values on CreateUserByPhoneReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateUserByPhoneReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserByPhoneReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateUserByPhoneReqMultiError, or nil if none found.
func (m *CreateUserByPhoneReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserByPhoneReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CreateUserByPhoneReq_UserPhone_Pattern.MatchString(m.GetUserPhone()) {
		err := CreateUserByPhoneReqValidationError{
			field:  "UserPhone",
			reason: "value does not match regex pattern \"^1[1-9]\\\\d{9}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUserNickname() != "" {

	}

	if m.GetUserAvatar() != "" {

	}

	if _, ok := _CreateUserByPhoneReq_UserGender_NotInLookup[m.GetUserGender()]; ok {
		err := CreateUserByPhoneReqValidationError{
			field:  "UserGender",
			reason: "value must not be in list [UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateUserByPhoneReq_UserStatus_NotInLookup[m.GetUserStatus()]; ok {
		err := CreateUserByPhoneReqValidationError{
			field:  "UserStatus",
			reason: "value must not be in list [INITIAL]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateUserByPhoneReq_Password_Pattern.MatchString(m.GetPassword()) {
		err := CreateUserByPhoneReqValidationError{
			field:  "Password",
			reason: "value does not match regex pattern \"^.{6,}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateUserByPhoneReqMultiError(errors)
	}

	return nil
}

// CreateUserByPhoneReqMultiError is an error wrapping multiple validation
// errors returned by CreateUserByPhoneReq.ValidateAll() if the designated
// constraints aren't met.
type CreateUserByPhoneReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserByPhoneReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserByPhoneReqMultiError) AllErrors() []error { return m }

// CreateUserByPhoneReqValidationError is the validation error returned by
// CreateUserByPhoneReq.Validate if the designated constraints aren't met.
type CreateUserByPhoneReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserByPhoneReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserByPhoneReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserByPhoneReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserByPhoneReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserByPhoneReqValidationError) ErrorName() string {
	return "CreateUserByPhoneReqValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserByPhoneReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserByPhoneReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserByPhoneReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserByPhoneReqValidationError{}

var _CreateUserByPhoneReq_UserPhone_Pattern = regexp.MustCompile("^1[1-9]\\d{9}$")

var _CreateUserByPhoneReq_UserGender_NotInLookup = map[enumv1.UserGenderEnum_UserGender]struct{}{
	0: {},
}

var _CreateUserByPhoneReq_UserStatus_NotInLookup = map[enumv1.UserStatusEnum_UserStatus]struct{}{
	0: {},
}

var _CreateUserByPhoneReq_Password_Pattern = regexp.MustCompile("^.{6,}$")

// Validate checks the field values on CreateUserResp with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateUserResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateUserResp with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateUserRespMultiError,
// or nil if none found.
func (m *CreateUserResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateUserResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Reason

	// no validation rules for Message

	// no validation rules for Metadata

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateUserRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateUserRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateUserRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateUserRespMultiError(errors)
	}

	return nil
}

// CreateUserRespMultiError is an error wrapping multiple validation errors
// returned by CreateUserResp.ValidateAll() if the designated constraints
// aren't met.
type CreateUserRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateUserRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateUserRespMultiError) AllErrors() []error { return m }

// CreateUserRespValidationError is the validation error returned by
// CreateUserResp.Validate if the designated constraints aren't met.
type CreateUserRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserRespValidationError) ErrorName() string { return "CreateUserRespValidationError" }

// Error satisfies the builtin error interface
func (e CreateUserRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserRespValidationError{}

// Validate checks the field values on CreateOrGetUserResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateOrGetUserResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrGetUserResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateOrGetUserRespMultiError, or nil if none found.
func (m *CreateOrGetUserResp) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrGetUserResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Reason

	// no validation rules for Message

	// no validation rules for Metadata

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateOrGetUserRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateOrGetUserRespValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateOrGetUserRespValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateOrGetUserRespMultiError(errors)
	}

	return nil
}

// CreateOrGetUserRespMultiError is an error wrapping multiple validation
// errors returned by CreateOrGetUserResp.ValidateAll() if the designated
// constraints aren't met.
type CreateOrGetUserRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrGetUserRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrGetUserRespMultiError) AllErrors() []error { return m }

// CreateOrGetUserRespValidationError is the validation error returned by
// CreateOrGetUserResp.Validate if the designated constraints aren't met.
type CreateOrGetUserRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrGetUserRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrGetUserRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrGetUserRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrGetUserRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrGetUserRespValidationError) ErrorName() string {
	return "CreateOrGetUserRespValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrGetUserRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrGetUserResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrGetUserRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrGetUserRespValidationError{}

// Validate checks the field values on CreateOrGetUserRespData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateOrGetUserRespData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrGetUserRespData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateOrGetUserRespDataMultiError, or nil if none found.
func (m *CreateOrGetUserRespData) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrGetUserRespData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateOrGetUserRespDataValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateOrGetUserRespDataValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateOrGetUserRespDataValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsCreate

	if len(errors) > 0 {
		return CreateOrGetUserRespDataMultiError(errors)
	}

	return nil
}

// CreateOrGetUserRespDataMultiError is an error wrapping multiple validation
// errors returned by CreateOrGetUserRespData.ValidateAll() if the designated
// constraints aren't met.
type CreateOrGetUserRespDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrGetUserRespDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrGetUserRespDataMultiError) AllErrors() []error { return m }

// CreateOrGetUserRespDataValidationError is the validation error returned by
// CreateOrGetUserRespData.Validate if the designated constraints aren't met.
type CreateOrGetUserRespDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrGetUserRespDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrGetUserRespDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrGetUserRespDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrGetUserRespDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrGetUserRespDataValidationError) ErrorName() string {
	return "CreateOrGetUserRespDataValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrGetUserRespDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrGetUserRespData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrGetUserRespDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrGetUserRespDataValidationError{}
